import { ref, reactive, readonly } from 'vue'; 
import type { Ref, DeepReadonly } from 'vue';

export interface CadastroForm {
  id: number | null;
  nome: string; 
  documento: string; // CPF/CNPJ (somente números)
  telefone: string;
  bloqueado: boolean;
}

export interface Cadastro extends Omit<CadastroForm, 'id'> { // Herda tudo, exceto 'id'
    id: number;
    bloqueado: boolean;
}

// --- Simulação de API e Estado Centralizado ---
interface ApiResponse<T> {
    data: T;
}

// Simulação tipada do axios
const axios = {
  // GET retorna a lista de cadastros (todos têm ID)
  get: (url: string): Promise<ApiResponse<Cadastro[]>> => simulateApiCall('GET', url), 
  
  // POST/PUT recebem CadastroForm (que inclui o formulário)
  post: (url: string, data: CadastroForm): Promise<ApiResponse<Cadastro>> => simulateApiCall('POST', url, data),
  put: (url: string, data: CadastroForm): Promise<ApiResponse<Cadastro>> => simulateApiCall('PUT', url, data),
  delete: (url: string): Promise<any> => simulateApiCall('DELETE', url),
};

const initialFormState: CadastroForm = {
  id: null,
  nome: '',
  documento: '',
  telefone: '',
  bloqueado: false,
};

const cadastros: Ref<Cadastro[]> = ref([
    // Dados iniciais devem seguir a tipagem 'Cadastro'
    { id: 1, nome: 'Empresa Alpha', documento: '10825310000101', telefone: '51988887777', bloqueado: false },
    { id: 2, nome: 'Maria Lima', documento: '12345678901', telefone: '11999990000', bloqueado: false },
]) as Ref<Cadastro[]>;

const form: CadastroForm = reactive({ ...initialFormState }); 
const loading: Ref<boolean> = ref(false); 
const error: Ref<string | null> = ref(null); 
const isEditing: Ref<boolean> = ref(false);

let nextId: number = 3;

// --- Simulação de API REST (Tipada) ---
async function simulateApiCall(method: string, url: string, data: CadastroForm | null = null): Promise<any> {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (Math.random() > 0.1) {
        let responseData: any;
        
        if (method === 'GET' && url === '/api/cadastros') {
            responseData = { data: cadastros.value };
        } else if (method === 'POST' && data) {
            const { id, ...restOfData } = data; 
            const newCad: Cadastro = { 
                id: nextId++,
                ...restOfData,
                bloqueado: false,
            } as Cadastro; 
            cadastros.value.push(newCad);
            responseData = { data: newCad };
        } else if ((method === 'PUT' || method === 'PATCH') && data && data.id !== null) {
            const id = data.id;
            const index = cadastros.value.findIndex(c => c.id === id);
            if (index !== -1) {
                const targetCad: Cadastro = cadastros.value[index] as Cadastro;
                Object.assign(targetCad, data as Cadastro); 
                responseData = { data: targetCad };
            } else {
                return reject(new Error('Cadastro não encontrado para atualização.'));
            }
        } else if (method === 'DELETE') {
            const id = Number(url.split('/').pop());
            cadastros.value = cadastros.value.filter(c => c.id !== id);
            responseData = { status: 'success' };
        } else {
            responseData = {};
        }
        resolve(responseData);
      } else {
        reject(new Error(`Falha simulada na requisição ${method} ${url}`));
      }
    }, 500); 
  });
}

export const resetForm = (): void => {
  Object.assign(form, initialFormState); 
  isEditing.value = false;
  error.value = null;
};

export const fetchCadastros = async (): Promise<void> => {
  loading.value = true;
  error.value = null;
  try {
    const response = await axios.get('/api/cadastros');
    cadastros.value = response.data;
  } catch (err: any) {
    error.value = `Erro ao buscar cadastros: ${err.message}`;
    console.error(err);
  } finally {
    loading.value = false;
  }
};

export const saveCadastro = async (): Promise<boolean> => {
  loading.value = true;
  error.value = null;
  
  try {
    const dataToSend: CadastroForm = { ...form }; 

    if (isEditing.value && dataToSend.id !== null) {
      // PUT espera CadastroForm
      await axios.put(`/api/cadastros/${dataToSend.id}`, dataToSend);
    } else {
      // POST espera CadastroForm
      await axios.post('/api/cadastros', dataToSend);
    }
    return true; 
  } catch (err: any) {
    error.value = `Erro ao salvar cadastro: ${err.message}`;
    console.error(err);
    return false;
  } finally {
    loading.value = false;
  }
};

export const deleteCadastro = async (id: number): Promise<boolean> => {
  loading.value = true;
  error.value = null;

  try {
    await axios.delete(`/api/cadastros/${id}`);
    return true;
  } catch (err: any) {
    error.value = `Erro ao excluir cadastro: ${err.message}`;
    console.error(err);
    return false;
  } finally {
    loading.value = false;
  }
};

export const toggleBlockStatus = (id: number): void => {
    const index = cadastros.value.findIndex(c => c.id === id);
    if (index !== -1) {
        const currentCad = cadastros.value[index]!;
        
        // Simulação de chamada PUT/PATCH (idealmente, você faria uma chamada aqui)
        console.log(`Simulando PATCH/PUT para ${id} com bloqueado: ${!currentCad.bloqueado}`);
        
        // Como o array é readonly, usamos Object.assign para alterar o objeto interno
        Object.assign(currentCad, { 
            bloqueado: !currentCad.bloqueado 
        });
        
        // Dispara uma atualização simulada no backend (opcional, mas bom para consistência)
        // const updatedForm: CadastroForm = { ...currentCad, id: currentCad.id };
        // axios.put(`/api/cadastros/${currentCad.id}`, updatedForm);
    }
};

// --- Função Principal Composable (Tipada) ---
export function useCadastros() {
    return {
        // Estado
        cadastros: readonly(cadastros) as DeepReadonly<Ref<Cadastro[]>>, // Lista tipada como Cadastro[]
        form: form as CadastroForm, // Form tipado como CadastroForm
        loading: readonly(loading),
        error: readonly(error),
        isEditing,

        // Ações
        fetchCadastros,
        saveCadastro,
        deleteCadastro,
        resetForm,
        toggleBlockStatus,
    };
}